--Tables/Sectioning tables: https://postgrespro.ru/docs/postgresql/10/sql-createtable
--: https://postgrespro.ru/docs/postgresql/10/ddl-partitioning
/*Сама по себе секционируемая таблица не содержит данных. 
Строка данных, вставляемая в эту таблицу, перенаправляется в секцию в зависимости от значений столбцов или выражений в ключе разбиения. 
Если значениям в новой строке не соответствует ни одна из существующих секций, возникает ошибка.*/

CREATE TABLE films (
    code        char(5) PRIMARY KEY, -- В чем разница если бы было "CONSTRAINT firstkey PRIMARY KEY,"
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute -- about interval: http://www.postgresqltutorial.com/postgresql-interval/  and -- https://postgrespro.ru/docs/postgrespro/9.5/datatype-datetime
);

SELECT * FROM films;
DROP TABLE films;

INSERT INTO films VALUES ('123','Test_1',1,now(),'Horror','1 days 1 hours 3 minutes');
INSERT INTO films VALUES ('123ee','Test_interval',1,now(),'Horror','3 months 4 days 11:12:12');
------------------------------------------------------------------------------

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, -- WE Should use 'DEFAULT' 
     name   varchar(40) NOT NULL CHECK (name <> '')
);
INSERT INTO distributors VALUES (DEFAULT,'asd');--USING DEFAULT
INSERT INTO distributors VALUES (DEFAULT,'TEst_num_2');
INSERT INTO distributors VALUES (DEFAULT,'TEst_num_3');

SELECT * FROM distributors;

-----------------------------------------------------------------------------------------------------------------------------
/*Partitioning: https://postgrespro.ru/docs/postgresql/10/ddl-partitioning
--EXAMPL:
Предположим, что мы создаём базу данных для большой компании, торгующей мороженым. 
Компания учитывает максимальную температуру и продажи мороженого каждый день в разрезе регионов. По сути нам нужна следующая таблица:
*/
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
DROP TABLE measurement;
/*
Мы знаем, что большинство запросов будут работать только с данными за последнюю неделю, месяц или квартал, 
так как в основном эта таблица нужна для формирования текущих отчётов для руководства. 
Чтобы сократить объём хранящихся старых данных, мы решили оставлять данные только за 3 последних года. 
Ненужные данные мы будем удалять в начале каждого месяца. 
В этой ситуации мы можем использовать секционирование для удовлетворения всех наших требований к таблице показателей.

Создайте таблицу measurement как секционированную таблицу с предложением PARTITION BY, 
указав метод разбиения (в нашем случае RANGE) и список столбцов, которые будут образовывать ключ разбиения.
*/
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
/*
Секции, создаваемые таким образом, во всех отношениях являются обычными таблицами PostgreSQL (или, возможно, сторонними таблицами). 
В частности, для каждой секции можно независимо задать табличное пространство и параметры хранения.
Для таблиц-секций нет необходимости определять ограничения с условиями, задающими границы значений. 
Нужные ограничения секций выводятся неявно из определения границ секции, когда требуется к ним обратиться.
*/

CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-08-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-08-01') TO ('2008-01-01');
	

	
CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4);
   -- TABLESPACE fasttablespace     -- Можно и НУЖНо указать табличное пространтсво
/*
Для реализации вложенного секционирования укажите предложение PARTITION BY в командах, создающих отдельные секции, например:
*/
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-08-01')
    PARTITION BY RANGE (peaktemp);
	
--Create index for each partition table 
/*
Создайте индекс по ключевому столбцу(ам), а также любые другие индексы, которые вы хотели бы иметь в каждой секции. 
(Индекс по ключу, строго говоря, не необходим, но в большинстве случаев он будет полезен. 
Если вы хотите, чтобы значения ключа были уникальны, вам следует также создать ограничения уникальности или первичного ключа для каждой секции.)
*/
CREATE INDEX ON measurement_y2006m02 (logdate);
CREATE INDEX ON measurement_y2006m03 (logdate);
CREATE INDEX ON measurement_y2008m01 (logdate);

/*
Убедитесь в том, что параметр конфигурации constraint_exclusion не выключен в postgresql.conf. Иначе запросы не будут оптимизироваться должным образом.
В данном примере нам потребуется создавать секцию каждый месяц, так что было бы разумно написать скрипт, который бы формировал требуемый код DDL автоматически.
*/
--CHECK:
INSERT INTO measurement VALUES (1,'2006-03-12',30,100);
SELECT * FROM measurement;
SELECT * FROM measurement_y2006m02;

---------------------------------------------------------------------------------------------------
--Section maintenance:
--The easiest way to delete old data is to simply delete the section that has become unnecessary:
DROP TABLE measurement_y2006m02;
/*
Так можно удалить миллионы записей гораздо быстрее, чем удалять их по одной. 
Заметьте, однако, что приведённая выше команда требует установления блокировки ACCESS EXCLUSIVE.


Ещё один часто более предпочтительный вариант — убрать секцию из главной таблицы, но сохранить возможность обращаться к ней как к самостоятельной таблице:
*/
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
/*
При этом можно будет продолжать работать с данными, пока таблица не будет удалена. 
Например, в этом состоянии очень кстати будет сделать резервную копию данных, используя COPY, pg_dump или подобные средства. 
Возможно, эти данные также можно будет агрегировать, перевести в компактный формат, выполнить другую обработку или построить отчёты.

+ Можем добавить секцию
*/

CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
/*
А иногда удобнее создать новую таблицу вне структуры секций и сделать её полноценной секцией позже. 
При таком подходе данные можно будет загрузить, проверить и преобразовать до того, как они появятся в секционированной таблице:
*/
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate >= DATE '2008-02-01' AND logdate < DATE '2008-03-01' );

--\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
	
/*
Прежде чем выполнять команду ATTACH PARTITION, рекомендуется создать ограничение CHECK в присоединяемой таблице, 
описывающее желаемое ограничение секции. Благодаря этому система сможет не сканировать таблицу для проверки выполнения неявного ограничения секции. 
Без этого ограничения таблицу нужно будет просканировать и убедиться в выполнении ограничения секции, удерживая блокировку ACCESS EXCLUSIVE в родительской таблице. 
После выполнения команды ATTACH PARTITION это ограничение можно будет удалить за ненадобностью.
*/


-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
--Партиционироваине через насследование

CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
--Создаем дочерние таблицы -- Create child tables
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
DROP TABLE measurement_y2006m02;
DROP TABLE measurement_y2006m03;
DROP TABLE measurement_y2007m11;

--Adding the constraints
ALTER TABLE measurement_y2006m02 ADD CONSTRAINT c1 CHECK (logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01');
--But it would be better to use such as Creating a sectioning:
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate >= DATE '2006-03-01' AND logdate < DATE '2007-11-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate >= DATE '2007-11-01' AND logdate < DATE '2007-12-01' )
) INHERITS (measurement);
----------------------------------------------------------------------------
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate); -- It's our last section

/*
Мы хотим, чтобы наше приложение могло сказать INSERT INTO measurement ... 
и данные оказались в соответствующей таблице-секции. Мы можем добиться этого, добавив подходящую триггерную функцию в главную таблицу. 
Если данные всегда будут добавляться только в последнюю секцию, нам будет достаточно очень простой функции:
*/
--ABOUT TRIGGER'S PROCEDURE --: https://postgrespro.ru/docs/postgresql/9.6/plpgsql-trigger

CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2007m11 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;

--After creation this function we create trigger that call it:
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();




--------------------------------------------------------------------------------
--Для того, чтобы сервер сам автоматичестки определял в какую секцию нужно направить данную строку

CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate >= DATE '2006-02-01' AND
         NEW.logdate < DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate >= DATE '2006-03-01' AND
            NEW.logdate < DATE '2007-11-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ELSIF ( NEW.logdate >= DATE '2007-11-01' AND
            NEW.logdate < DATE '2007-12-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION
  'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;









	







	





















